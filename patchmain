diff --git a/compiler/ghc.cabal.in b/compiler/ghc.cabal.in
index 70f7c16..b4386a9 100644
--- a/compiler/ghc.cabal.in
+++ b/compiler/ghc.cabal.in
@@ -387,6 +387,7 @@ Library
         TcCanonical
         TcSMonad
         TcTypeNats
+        TcTypeSymbols
         TcSplice
         Class
         Coercion
diff --git a/compiler/ghc.mk b/compiler/ghc.mk
index f1eb535..acf783f 100644
--- a/compiler/ghc.mk
+++ b/compiler/ghc.mk
@@ -451,7 +451,7 @@ compiler_stage3_SplitObjs = NO
 # We therefore need to split some of the modules off into a separate
 # DLL. This clump are the modules reachable from DynFlags:
 compiler_stage2_dll0_START_MODULE = DynFlags
-compiler_stage2_dll0_MODULES = Annotations Avail Bag BasicTypes BinIface Binary Bitmap BlockId BooleanFormula BreakArray BufWrite BuildTyCl ByteCodeAsm ByteCodeInstr ByteCodeItbls CLabel Class CmdLineParser Cmm CmmCallConv CmmExpr CmmInfo CmmMachOp CmmNode CmmType CmmUtils CoAxiom CodeGen.Platform CodeGen.Platform.ARM CodeGen.Platform.NoRegs CodeGen.Platform.PPC CodeGen.Platform.PPC_Darwin CodeGen.Platform.SPARC CodeGen.Platform.X86 CodeGen.Platform.X86_64 Coercion Config Constants CoreArity CoreFVs CoreLint CoreSubst CoreSyn CoreTidy CoreUnfold CoreUtils CostCentre DataCon Demand Digraph DriverPhases DsMonad DynFlags Encoding ErrUtils Exception ExtsCompat46 FamInstEnv FastBool FastFunctions FastMutInt FastString FastTypes Finder Fingerprint FiniteMap ForeignCall Hooks Hoopl Hoopl.Dataflow HsBinds HsDecls HsDoc HsExpr HsImpExp HsLit HsPat HsSyn HsTypes HsUtils HscTypes IOEnv Id IdInfo IfaceEnv IfaceSyn IfaceType InstEnv InteractiveEvalTypes Kind ListSetOps Literal LoadIface Maybes MkCore MkGraph MkId Module MonadUtils Name NameEnv NameSet OccName OccurAnal OptCoercion OrdList Outputable PackageConfig Packages Pair Panic PipelineMonad Platform PlatformConstants PprCmm PprCmmDecl PprCmmExpr PprCore PrelInfo PrelNames PrelRules Pretty PrimOp RdrName Reg RegClass Rules SMRep Serialized SrcLoc StaticFlags StgCmmArgRep StgCmmClosure StgCmmEnv StgCmmLayout StgCmmMonad StgCmmProf StgCmmTicky StgCmmUtils StgSyn Stream StringBuffer TcEvidence TcIface TcRnMonad TcRnTypes TcType TcTypeNats TrieMap TyCon Type TypeRep TysPrim TysWiredIn Unify UniqFM UniqSet UniqSupply Unique Util Var VarEnv VarSet
+compiler_stage2_dll0_MODULES = Annotations Avail Bag BasicTypes BinIface Binary Bitmap BlockId BooleanFormula BreakArray BufWrite BuildTyCl ByteCodeAsm ByteCodeInstr ByteCodeItbls CLabel Class CmdLineParser Cmm CmmCallConv CmmExpr CmmInfo CmmMachOp CmmNode CmmType CmmUtils CoAxiom CodeGen.Platform CodeGen.Platform.ARM CodeGen.Platform.NoRegs CodeGen.Platform.PPC CodeGen.Platform.PPC_Darwin CodeGen.Platform.SPARC CodeGen.Platform.X86 CodeGen.Platform.X86_64 Coercion Config Constants CoreArity CoreFVs CoreLint CoreSubst CoreSyn CoreTidy CoreUnfold CoreUtils CostCentre DataCon Demand Digraph DriverPhases DsMonad DynFlags Encoding ErrUtils Exception ExtsCompat46 FamInstEnv FastBool FastFunctions FastMutInt FastString FastTypes Finder Fingerprint FiniteMap ForeignCall Hooks Hoopl Hoopl.Dataflow HsBinds HsDecls HsDoc HsExpr HsImpExp HsLit HsPat HsSyn HsTypes HsUtils HscTypes IOEnv Id IdInfo IfaceEnv IfaceSyn IfaceType InstEnv InteractiveEvalTypes Kind ListSetOps Literal LoadIface Maybes MkCore MkGraph MkId Module MonadUtils Name NameEnv NameSet OccName OccurAnal OptCoercion OrdList Outputable PackageConfig Packages Pair Panic PipelineMonad Platform PlatformConstants PprCmm PprCmmDecl PprCmmExpr PprCore PrelInfo PrelNames PrelRules Pretty PrimOp RdrName Reg RegClass Rules SMRep Serialized SrcLoc StaticFlags StgCmmArgRep StgCmmClosure StgCmmEnv StgCmmLayout StgCmmMonad StgCmmProf StgCmmTicky StgCmmUtils StgSyn Stream StringBuffer TcEvidence TcIface TcRnMonad TcRnTypes TcType TcTypeNats TcTypeSymbols TrieMap TyCon Type TypeRep TysPrim TysWiredIn Unify UniqFM UniqSet UniqSupply Unique Util Var VarEnv VarSet
 
 compiler_stage2_dll0_HS_OBJS = \
     $(patsubst %,compiler/stage2/build/%.$(dyn_osuf),$(subst .,/,$(compiler_stage2_dll0_MODULES)))
diff --git a/compiler/iface/TcIface.lhs b/compiler/iface/TcIface.lhs
index 7376169..98fb416 100644
--- a/compiler/iface/TcIface.lhs
+++ b/compiler/iface/TcIface.lhs
@@ -19,6 +19,7 @@ module TcIface (
 #include "HsVersions.h"
 
 import TcTypeNats(typeNatCoAxiomRules)
+import TcTypeSymbols(typeSymbolCoAxiomRules)
 import IfaceSyn
 import LoadIface
 import IfaceEnv
@@ -1036,9 +1037,10 @@ tcIfaceCoVar = tcIfaceLclId
 
 tcIfaceCoAxiomRule :: FastString -> IfL CoAxiomRule
 tcIfaceCoAxiomRule n =
-  case Map.lookup n typeNatCoAxiomRules of
+  case Map.lookup n rules of
     Just ax -> return ax
     _  -> pprPanic "tcIfaceCoAxiomRule" (ppr n)
+  where rules = Map.unions [typeNatCoAxiomRules, typeSymbolCoAxiomRules]
 \end{code}
 
 
diff --git a/compiler/prelude/PrelInfo.lhs b/compiler/prelude/PrelInfo.lhs
index bfcea1c..dfc5419 100644
--- a/compiler/prelude/PrelInfo.lhs
+++ b/compiler/prelude/PrelInfo.lhs
@@ -43,7 +43,7 @@ import Class
 import TyCon
 import Util
 import {-# SOURCE #-} TcTypeNats ( typeNatTyCons )
-
+import {-# SOURCE #-} TcTypeSymbols ( typeSymbolTyCons )
 import Data.Array
 \end{code}
 
@@ -91,7 +91,7 @@ wiredInThings
     ]
   where
     tycon_things = map ATyCon ([funTyCon] ++ primTyCons ++ wiredInTyCons
-                                    ++ typeNatTyCons)
+                                    ++ typeNatTyCons ++ typeSymbolTyCons)
 \end{code}
 
 We let a lot of "non-standard" values be visible, so that we can make
diff --git a/compiler/prelude/PrelNames.lhs b/compiler/prelude/PrelNames.lhs
index 85da3ac..22fb47c 100644
--- a/compiler/prelude/PrelNames.lhs
+++ b/compiler/prelude/PrelNames.lhs
@@ -1477,7 +1477,7 @@ rep1TyConKey = mkPreludeTyConUnique 156
 -- Type-level naturals
 typeNatKindConNameKey, typeSymbolKindConNameKey,
   typeNatAddTyFamNameKey, typeNatMulTyFamNameKey, typeNatExpTyFamNameKey,
-  typeNatLeqTyFamNameKey, typeNatSubTyFamNameKey
+  typeNatLeqTyFamNameKey, typeNatSubTyFamNameKey, typeSymbolLeqTyFamNameKey
   :: Unique
 typeNatKindConNameKey     = mkPreludeTyConUnique 160
 typeSymbolKindConNameKey  = mkPreludeTyConUnique 161
@@ -1487,6 +1487,11 @@ typeNatExpTyFamNameKey    = mkPreludeTyConUnique 164
 typeNatLeqTyFamNameKey    = mkPreludeTyConUnique 165
 typeNatSubTyFamNameKey    = mkPreludeTyConUnique 166
 
+
+-- Type-level symbols
+
+typeSymbolLeqTyFamNameKey    = mkPreludeTyConUnique 167
+
 ntTyConKey:: Unique
 ntTyConKey = mkPreludeTyConUnique 174
 coercibleTyConKey :: Unique
diff --git a/compiler/typecheck/TcTypeSymbols.hs b/compiler/typecheck/TcTypeSymbols.hs
new file mode 100644
index 0000000..69a2c2f
--- /dev/null
+++ b/compiler/typecheck/TcTypeSymbols.hs
@@ -0,0 +1,188 @@
+module TcTypeSymbols
+  ( typeSymbolTyCons
+  , typeSymbolCoAxiomRules
+  , BuiltInSynFamily(..)
+  ) where
+
+import Type
+import Pair
+import TcType     ( TcType, tcEqType )
+import TyCon      ( TyCon, SynTyConRhs(..), mkSynTyCon, TyConParent(..)  )
+import Coercion   ( Role(..) )
+import TcRnTypes  ( Xi )
+import CoAxiom    ( CoAxiomRule(..), BuiltInSynFamily(..) )
+import Name       ( Name, BuiltInSyntax(..) )
+import TysWiredIn ( typeSymbolKind, mkWiredInTyConName
+                  , promotedBoolTyCon
+                  , promotedFalseDataCon, promotedTrueDataCon
+                  )
+import TysPrim    ( tyVarList, mkArrowKinds )
+import PrelNames  ( gHC_TYPELITS
+                  , typeSymbolLeqTyFamNameKey
+                  )
+import FastString ( FastString, fsLit )
+import qualified Data.Map as Map
+import Data.Maybe ( isJust )
+
+{-------------------------------------------------------------------------------
+Built-in type constructors for functions on type-lelve symbolss
+-}
+
+typeSymbolTyCons :: [TyCon]
+typeSymbolTyCons =
+  [ typeSymbolLeqTyCon]
+
+
+typeSymbolLeqTyCon :: TyCon
+typeSymbolLeqTyCon =
+  mkSynTyCon name
+    (mkArrowKinds [ typeSymbolKind, typeSymbolKind ] boolKind)
+    (take 2 $ tyVarList typeSymbolKind)
+    [Nominal,Nominal]
+    (BuiltInSynFamTyCon ops)
+    NoParentTyCon
+
+  where
+  name = mkWiredInTyConName UserSyntax gHC_TYPELITS (fsLit "<=.?")
+                typeSymbolLeqTyFamNameKey typeSymbolLeqTyCon
+  ops = BuiltInSynFamily
+    { sfMatchFam      = matchFamLeq
+    , sfInteractTop   = interactTopLeq
+    , sfInteractInert = interactInertLeq
+    }
+
+
+
+
+
+{-------------------------------------------------------------------------------
+Built-in rules axioms
+-------------------------------------------------------------------------------}
+
+-- If you add additional rules, please remember to add them to
+-- `typeSymbolCoAxiomRules` also.
+axLeqDef
+  , axLeqRefl
+  :: CoAxiomRule
+
+
+axLeqDef = mkBinAxiom "LeqDefSym" typeSymbolLeqTyCon $
+              \x y -> Just $ bool (x <= y)
+
+axLeqRefl   = mkAxiom1 "LeqReflSym"  $ \t -> (t <== t) === bool True
+
+typeSymbolCoAxiomRules :: Map.Map FastString CoAxiomRule
+typeSymbolCoAxiomRules = Map.fromList $ map (\x -> (coaxrName x, x))
+  [ axLeqDef
+  , axLeqRefl
+  ]
+
+
+
+{-------------------------------------------------------------------------------
+Various utilities for making axioms and types
+-------------------------------------------------------------------------------}
+
+(===) :: Type -> Type -> Pair Type
+x === y = Pair x y
+
+(<==) :: Type -> Type -> Type
+s <== t = mkTyConApp typeSymbolLeqTyCon [s,t]
+
+boolKind :: Kind
+boolKind = mkTyConApp promotedBoolTyCon []
+
+bool :: Bool -> Type
+bool b = if b then mkTyConApp promotedTrueDataCon []
+              else mkTyConApp promotedFalseDataCon []
+
+isBoolLitTy :: Type -> Maybe Bool
+isBoolLitTy tc =
+  do (tc,[]) <- splitTyConApp_maybe tc
+     case () of
+       _ | tc == promotedFalseDataCon -> return False
+         | tc == promotedTrueDataCon  -> return True
+         | otherwise                   -> Nothing
+
+known :: (FastString -> Bool) -> TcType -> Bool
+known p x = case isStrLitTy x of
+              Just a  -> p a
+              Nothing -> False
+
+
+
+
+-- For the definitional axioms
+mkBinAxiom :: String -> TyCon ->
+              (FastString -> FastString -> Maybe Type) -> CoAxiomRule
+mkBinAxiom str tc f =
+  CoAxiomRule
+    { coaxrName      = fsLit str
+    , coaxrTypeArity = 2
+    , coaxrAsmpRoles = []
+    , coaxrRole      = Nominal
+    , coaxrProves    = \ts cs ->
+        case (ts,cs) of
+          ([s,t],[]) -> do x <- isStrLitTy s
+                           y <- isStrLitTy t
+                           z <- f x y
+                           return (mkTyConApp tc [s,t] === z)
+          _ -> Nothing
+    }
+
+mkAxiom1 :: String -> (Type -> Pair Type) -> CoAxiomRule
+mkAxiom1 str f =
+  CoAxiomRule
+    { coaxrName      = fsLit str
+    , coaxrTypeArity = 1
+    , coaxrAsmpRoles = []
+    , coaxrRole      = Nominal
+    , coaxrProves    = \ts cs ->
+        case (ts,cs) of
+          ([s],[]) -> return (f s)
+          _        -> Nothing
+    }
+
+
+{-------------------------------------------------------------------------------
+Evaluation
+-------------------------------------------------------------------------------}
+
+
+matchFamLeq :: [Type] -> Maybe (CoAxiomRule, [Type], Type)
+matchFamLeq [s,t]
+  | Just x <- mbX, Just y <- mbY =
+    Just (axLeqDef, [s,t], bool (x <= y))
+  | tcEqType s t  = Just (axLeqRefl, [s], bool True)
+  where mbX = isStrLitTy s
+        mbY = isStrLitTy t
+matchFamLeq _ = Nothing
+
+
+interactTopLeq :: [Xi] -> Xi -> [Pair Type]
+interactTopLeq _ _ = []
+
+
+{-------------------------------------------------------------------------------
+Interaction with inerts
+-------------------------------------------------------------------------------}
+
+
+
+
+interactInertLeq :: [Xi] -> Xi -> [Xi] -> Xi -> [Pair Type]
+interactInertLeq [x1,y1] z1 [x2,y2] z2
+  | bothTrue && tcEqType x1 y2 && tcEqType y1 x2 = [ x1 === y1 ]
+  | bothTrue && tcEqType y1 x2                 = [ (x1 <== y2) === bool True ]
+  | bothTrue && tcEqType y2 x1                 = [ (x2 <== y1) === bool True ]
+  where bothTrue = isJust $ do True <- isBoolLitTy z1
+                               True <- isBoolLitTy z2
+                               return ()
+
+interactInertLeq _ _ _ _ = []
+
+
+
+
+
+
diff --git a/compiler/typecheck/TcTypeSymbols.hs-boot b/compiler/typecheck/TcTypeSymbols.hs-boot
new file mode 100644
index 0000000..acc7773
--- /dev/null
+++ b/compiler/typecheck/TcTypeSymbols.hs-boot
@@ -0,0 +1,5 @@
+module TcTypeSymbols where
+
+import TyCon (TyCon)
+
+typeSymbolTyCons :: [TyCon]
